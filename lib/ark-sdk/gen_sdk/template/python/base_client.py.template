#!/usr/bin/env python3
"""
Generated ARK Kubernetes Client Classes

This module provides typed client classes for interacting with ARK custom resources.
Auto-generated from OpenAPI schema - do not edit manually.
"""

import os
import functools
import logging
import asyncio
from typing import List, Optional, Dict, Any, TypeVar, Generic, Type, Union, Tuple, Callable
from kubernetes import client, config
from kubernetes.client.rest import ApiException
from ark_sdk.k8s import get_context
import yaml
import json

T = TypeVar('T')

# Configure logger
logger = logging.getLogger(__name__)

def async_compat(async_method):
    """Decorator that makes async methods work in both sync and async contexts"""
    @functools.wraps(async_method)
    def wrapper(*args, **kwargs):
        try:
            # Check if we're in an async context
            loop = asyncio.get_running_loop()
            # Return the coroutine for the caller to await
            return async_method(*args, **kwargs)
        except RuntimeError:
            # No event loop, run it synchronously
            return asyncio.run(async_method(*args, **kwargs))
    return wrapper

@functools.lru_cache(maxsize=1)
def init_k8s():
    # Initialize Kubernetes client
    try:
        config.load_incluster_config()
        logger.info("Loaded in-cluster Kubernetes configuration")
    except (config.ConfigException, Exception) as e:
        logger.warning(f"Failed to load in-cluster config: {e}. Falling back to kubeconfig")
        try:
            config.load_kube_config()
            logger.info("Loaded Kubernetes configuration from kubeconfig")
        except (config.ConfigException, Exception) as e:
            logger.error(f"Failed to load Kubernetes configuration: {e}")
            raise

class ARKResourceClient(Generic[T]):
    """Generic client for ARK custom resources"""
    
    def __init__(
        self,
        api_version: str,
        kind: str,
        plural: str,
        model_class: Type[T],
        namespace: str = "default"
    ):
        self.api_version = api_version
        self.kind = kind
        self.plural = plural
        self.model_class = model_class
        self.namespace = namespace
        self.group, self.version = api_version.split('/')
       
        init_k8s()

        self.api_client = client.ApiClient()
        self.custom_api = client.CustomObjectsApi(self.api_client)
    
    def create(self, resource: T, namespace: Optional[str] = None) -> T:
        """Create a new resource"""
        ns = namespace or self.namespace
        
        # Convert the typed model to dict
        body = self._model_to_dict(resource)
        
        # Ensure required fields are set
        body['apiVersion'] = self.api_version
        body['kind'] = self.kind
        
        try:
            result = self.custom_api.create_namespaced_custom_object(
                group=self.group,
                version=self.version,
                namespace=ns,
                plural=self.plural,
                body=body
            )
            return self._dict_to_model(result)
        except ApiException as e:
            raise Exception(f"Failed to create {self.kind}: {e}")
    
    def get(self, name: str, namespace: Optional[str] = None) -> T:
        """Get a resource by name"""
        ns = namespace or self.namespace
        
        try:
            result = self.custom_api.get_namespaced_custom_object(
                group=self.group,
                version=self.version,
                namespace=ns,
                plural=self.plural,
                name=name
            )
            return self._dict_to_model(result)
        except ApiException as e:
            if e.status == 404:
                raise Exception(f"{self.kind} '{name}' not found in namespace '{ns}'")
            raise Exception(f"Failed to get {self.kind}: {e}")
    
    def list(
        self, 
        namespace: Optional[str] = None, 
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        continue_token: Optional[str] = None
    ) -> List[T]:
        """List all resources
        
        Args:
            namespace: The namespace to list resources from
            label_selector: Optional label selector for filtering
            limit: Maximum number of items to return per page (enables pagination)
            continue_token: Token from previous response to get next page
            
        Returns:
            List of resource models. If limit is provided, returns a tuple:
            (List[T], Optional[str], Optional[Dict]) where the second element is the 
            continue token and the third is metadata with 'remainingItemCount'.
        """
        ns = namespace or self.namespace
        
        try:
            kwargs = {}
            if label_selector:
                kwargs['label_selector'] = label_selector
            if limit is not None:
                kwargs['limit'] = limit
            if continue_token:
                kwargs['_continue'] = continue_token
            
            result = self.custom_api.list_namespaced_custom_object(
                group=self.group,
                version=self.version,
                namespace=ns,
                plural=self.plural,
                **kwargs
            )
            
            items = result.get('items', [])
            models = [self._dict_to_model(item) for item in items]
            
            # If limit was provided, return pagination info
            if limit is not None:
                metadata = result.get('metadata', {})
                continue_token = metadata.get('continue')
                remaining_count = metadata.get('remainingItemCount')
                pagination_metadata = {}
                if continue_token:
                    pagination_metadata['continue'] = continue_token
                if remaining_count is not None:
                    pagination_metadata['remainingItemCount'] = remaining_count
                return (models, continue_token, pagination_metadata if pagination_metadata else None)
            
            return models
        except ApiException as e:
            raise Exception(f"Failed to list {self.kind}s: {e}")
    
    def list_paginated(
        self,
        namespace: Optional[str] = None,
        label_selector: Optional[str] = None,
        page: int = 1,
        limit: int = 100,
        filter_func: Optional[Callable[[T], bool]] = None,
        sort_key: Optional[Callable[[T], Any]] = None,
        sort_reverse: bool = False
    ) -> Tuple[List[T], int]:
        """List resources with page-based pagination, filtering, and sorting.
        
        This method fetches ALL resources from Kubernetes (in efficient chunks),
        applies optional filtering and sorting client-side, then returns the 
        requested page with total count.
    
        Args:
            namespace: The namespace to list resources from
            label_selector: Optional label selector for Kubernetes-level filtering
            page: Page number (1-based, default: 1)
            limit: Number of items per page (default: 100)
            filter_func: Optional function to filter items. Should accept a model and return bool.
            sort_key: Optional function to extract sort key from model (used as key in sorted())
            sort_reverse: If True, sort in descending order (default: False)
            
        Returns:
            Tuple of (List[T], int): (paginated items, total count after filtering)
        """
        ns = namespace or self.namespace
        
        # IMPORTANT: We must fetch ALL items before sorting/filtering to ensure correct results.
        # Kubernetes doesn't support server-side sorting, so we fetch everything in chunks,
        # then apply client-side filtering, sorting, and pagination.
        all_items = []
        continue_token = None
        fetch_limit = 1000  # Chunk size per API call (not a total limit)
        
        try:
            # Fetch all items using Kubernetes pagination (continue until no more pages)
            while True:
                if continue_token:
                    items, next_token, _ = self.list(
                        namespace=ns,
                        label_selector=label_selector,
                        limit=fetch_limit,
                        continue_token=continue_token
                    )
                else:
                    result = self.list(
                        namespace=ns,
                        label_selector=label_selector,
                        limit=fetch_limit
                    )
                    if isinstance(result, tuple):
                        items, next_token, _ = result
                    else:
                        items = result
                        next_token = None
                
                all_items.extend(items)
                
                # Stop when there are no more pages
                if not next_token:
                    break
                continue_token = next_token
            
            # Now that we have ALL items, apply filtering
            if filter_func:
                all_items = [item for item in all_items if filter_func(item)]
            
            # Apply sorting to the complete filtered dataset
            if sort_key:
                all_items = sorted(all_items, key=sort_key, reverse=sort_reverse)
            
            # Apply page-based pagination
            total_count = len(all_items)
            
            # If limit is -1 or None, return all items (no pagination)
            if limit == -1 or limit is None:
                paginated_items = all_items
            else:
                start_index = (page - 1) * limit
                end_index = start_index + limit
                paginated_items = all_items[start_index:end_index]
            
            return paginated_items, total_count
            
        except Exception as e:
            raise Exception(f"Failed to list paginated {self.kind}s: {e}")
    
    def update(self, resource: T, namespace: Optional[str] = None) -> T:
        """Update an existing resource"""
        ns = namespace or self.namespace
        
        # Convert the typed model to dict
        body = self._model_to_dict(resource)
        
        # Ensure required fields are set
        body['apiVersion'] = self.api_version
        body['kind'] = self.kind
        
        # Extract name from metadata
        name = body.get('metadata', {}).get('name')
        if not name:
            raise ValueError("Resource must have metadata.name for update")
        
        try:
            result = self.custom_api.replace_namespaced_custom_object(
                group=self.group,
                version=self.version,
                namespace=ns,
                plural=self.plural,
                name=name,
                body=body
            )
            return self._dict_to_model(result)
        except ApiException as e:
            raise Exception(f"Failed to update {self.kind}: {e}")
    
    def patch(self, name: str, patch_data: Dict[str, Any], namespace: Optional[str] = None) -> T:
        """Patch a resource"""
        ns = namespace or self.namespace
        
        try:
            result = self.custom_api.patch_namespaced_custom_object(
                group=self.group,
                version=self.version,
                namespace=ns,
                plural=self.plural,
                name=name,
                body=patch_data
            )
            return self._dict_to_model(result)
        except ApiException as e:
            raise Exception(f"Failed to patch {self.kind}: {e}")
    
    def delete(self, name: str, namespace: Optional[str] = None) -> None:
        """Delete a resource"""
        ns = namespace or self.namespace
        
        try:
            self.custom_api.delete_namespaced_custom_object(
                group=self.group,
                version=self.version,
                namespace=ns,
                plural=self.plural,
                name=name
            )
        except ApiException as e:
            if e.status == 404:
                raise Exception(f"{self.kind} '{name}' not found in namespace '{ns}'")
            raise Exception(f"Failed to delete {self.kind}: {e}")
    
    def _model_to_dict(self, model: T) -> Dict[str, Any]:
        """Convert a typed model to a dictionary"""
        if hasattr(model, 'model_dump'):
            # Pydantic v2
            return model.model_dump(by_alias=True, exclude_unset=True)
        elif hasattr(model, 'dict'):
            # Pydantic v1
            return model.dict(by_alias=True, exclude_unset=True)
        else:
            raise ValueError(f"Cannot convert {type(model)} to dict")
    
    def _dict_to_model(self, data: Dict[str, Any]) -> T:
        """Convert a dictionary to a typed model"""
        return self.model_class(**data)
    
    # Async versions of all public methods
    @async_compat
    async def a_create(self, resource: T, namespace: Optional[str] = None) -> T:
        """Async version of create - works in both sync and async contexts"""
        return await asyncio.to_thread(self.create, resource, namespace)
    
    @async_compat
    async def a_get(self, name: str, namespace: Optional[str] = None) -> T:
        """Async version of get - works in both sync and async contexts"""
        return await asyncio.to_thread(self.get, name, namespace)
    
    @async_compat
    async def a_list(
        self, 
        namespace: Optional[str] = None, 
        label_selector: Optional[str] = None
    ) -> Union[List[T], Tuple[List[T], Optional[str], Optional[Dict[str, Any]]]]:
        """Async version of list - works in both sync and async contexts"""
        return await asyncio.to_thread(self.list, namespace, label_selector)
    
    @async_compat
    async def a_list_paginated(
        self,
        namespace: Optional[str] = None,
        label_selector: Optional[str] = None,
        page: int = 1,
        limit: int = 100,
        filter_func: Optional[Callable[[T], bool]] = None,
        sort_key: Optional[Callable[[T], Any]] = None,
        sort_reverse: bool = False
    ) -> Tuple[List[T], int]:
        """Async version of list_paginated - works in both sync and async contexts"""
        return await asyncio.to_thread(
            self.list_paginated,
            namespace,
            label_selector,
            page,
            limit,
            filter_func,
            sort_key,
            sort_reverse
        )
    
    @async_compat
    async def a_update(self, resource: T, namespace: Optional[str] = None) -> T:
        """Async version of update - works in both sync and async contexts"""
        return await asyncio.to_thread(self.update, resource, namespace)
    
    @async_compat
    async def a_patch(self, name: str, patch_data: Dict[str, Any], namespace: Optional[str] = None) -> T:
        """Async version of patch - works in both sync and async contexts"""
        return await asyncio.to_thread(self.patch, name, patch_data, namespace)
    
    @async_compat
    async def a_delete(self, name: str, namespace: Optional[str] = None) -> None:
        """Async version of delete - works in both sync and async contexts"""
        return await asyncio.to_thread(self.delete, name, namespace)


class _ARKClient:
    """Base ARK client class"""

    def __init__(self, namespace: Optional[str] = None):
        if namespace is None:
            namespace = get_context()["namespace"]
        self.namespace = namespace