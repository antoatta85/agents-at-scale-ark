# Ark API Server

Aggregated API Server for Ark resources with pluggable storage backends.

## Overview

The Ark API Server is a Kubernetes [aggregated API server](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/) that stores Ark resources outside of etcd. This addresses scalability limitations when running high-volume AI workloads.

### Supported Resources

All 10 Ark resource types are supported:

| Resource | Description |
|----------|-------------|
| Query | AI query requests and responses |
| Agent | AI agent definitions with prompts and tools |
| Model | AI model configurations (OpenAI, Azure, Bedrock) |
| Team | Multi-agent team orchestration |
| Tool | Tool definitions (HTTP, MCP, builtin) |
| Memory | Conversation memory persistence |
| MCPServer | MCP server connections |
| Evaluation | AI output evaluation jobs |
| Evaluator | Evaluation service configuration |
| A2ATask | Agent-to-agent task coordination |

## Why Not etcd?

Kubernetes stores all resources in etcd, which has practical limits:
- ~10-20k writes/sec shared across the entire cluster
- Queries generate 3-4 writes each (create, status updates, completion)
- High Query volume can impact cluster operations (pod scheduling, etc.)

The Ark API Server solves this by storing Ark resources in a dedicated database while maintaining full Kubernetes API compatibility.

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Kubernetes Cluster                               │
│                                                                          │
│   kubectl get queries       kubectl get pods                            │
│        │                         │                                       │
│        ▼                         ▼                                       │
│   ┌─────────────────────────────────────────────┐                       │
│   │              kube-apiserver                  │                       │
│   └─────────────────┬───────────────────────────┘                       │
│        ┌────────────┴────────────┐                                      │
│        ▼                         ▼                                       │
│   ┌──────────┐            ┌──────────────┐                              │
│   │  Core    │            │  Ark API     │  ← Aggregated API            │
│   │  (etcd)  │            │  Server      │                              │
│   │          │            │              │                              │
│   │  pods    │            │  queries     │                              │
│   │  services│            │  agents      │                              │
│   └──────────┘            │  models      │                              │
│                           └──────┬───────┘                              │
│                                  │                                       │
│                                  ▼                                       │
│                           ┌──────────────┐                              │
│                           │   Storage    │                              │
│                           │  SQLite /    │                              │
│                           │  PostgreSQL  │                              │
│                           └──────────────┘                              │
└─────────────────────────────────────────────────────────────────────────┘
```

## Storage Backends

### SQLite (Default)

Zero-configuration storage for development and small deployments.

- Single file database with WAL mode
- No external dependencies
- Suitable for development and single-node deployments
- Automatic schema initialization

### PostgreSQL

Production-ready storage with connection pooling.

- LISTEN/NOTIFY for efficient real-time WATCH events
- Connection pooling (25 max open, 5 idle)
- GIN indexes for label selector queries
- Automatic trigger-based change notifications
- Horizontal scaling support

## Configuration

### Helm Values

```yaml
storage:
  driver: sqlite  # or postgresql

  sqlite:
    path: /data/ark.db
    persistence:
      enabled: true
      size: 1Gi

  postgresql:
    host: postgres.example.com
    port: 5432
    database: ark
    username: ark
    existingSecret: ark-db-credentials
```

## Development

```bash
cd services/ark-apiserver

make help          # Show available commands
make generate      # Regenerate deepcopy after type changes
make build-binary  # Build locally
make test          # Run tests
make dev           # Run in development mode
```

### Running Tests

**SQLite tests** (no dependencies):
```bash
go test ./pkg/storage/sqlite/...
```

**PostgreSQL integration tests** (requires PostgreSQL):
```bash
# Start PostgreSQL (e.g., via Docker)
docker run -d --name ark-postgres \
  -e POSTGRES_DB=ark \
  -e POSTGRES_USER=ark \
  -e POSTGRES_PASSWORD=arktest \
  -p 5432:5432 postgres:15

# Run tests
POSTGRES_HOST=localhost \
POSTGRES_DB=ark \
POSTGRES_USER=ark \
POSTGRES_PASSWORD=arktest \
go test -v ./pkg/storage/postgresql/...
```

## Observability

### Prometheus Metrics

The Ark API Server exposes Prometheus metrics on port 8080 at `/metrics`.

**Storage Operations Metrics:**

| Metric | Type | Labels | Description |
|--------|------|--------|-------------|
| `ark_apiserver_storage_operations_total` | Counter | operation, kind, status | Total storage operations |
| `ark_apiserver_storage_latency_seconds` | Histogram | operation, kind | Operation latency |
| `ark_apiserver_active_resources` | Gauge | kind | Active resource count |

Labels:
- `operation`: create, get, list, update, delete
- `kind`: Agent, Query, Model, etc.
- `status`: success, error, not_found, validation_error

**Enable in Helm:**

```yaml
metrics:
  enabled: true
  port: 8080
  serviceMonitor:
    enabled: true  # Requires Prometheus Operator
    interval: 30s
```

**Scraping Metrics:**

```bash
kubectl port-forward -n ark-system svc/ark-apiserver 8080:8080
curl http://localhost:8080/metrics | grep ark_apiserver
```

### Health Checks

The API server provides standard Kubernetes health endpoints on port 8443:

- `/healthz` - Liveness probe
- `/readyz` - Readiness probe

## Performance

### Latency Targets

| Operation | Target p99 | Notes |
|-----------|------------|-------|
| Create | < 10ms | Single row insert |
| Get | < 5ms | Index lookup |
| List | < 50ms | Depends on result size |
| Update | < 10ms | Single row update |
| Delete | < 5ms | Soft delete |

### SQLite Tuning

SQLite is configured with:
- WAL (Write-Ahead Logging) mode for concurrent reads
- Synchronous=NORMAL for balanced durability/performance
- Busy timeout of 5000ms

### PostgreSQL Tuning

Recommended PostgreSQL settings for production:
- `max_connections`: 100+
- `shared_buffers`: 25% of RAM
- `effective_cache_size`: 75% of RAM
- Connection pooling via PgBouncer or internal pooling

The API server uses:
- 25 max open connections
- 5 idle connections
- Connection lifetime management

## High Availability

### Requirements

| Backend | HA Support | Notes |
|---------|------------|-------|
| SQLite | No | Single-writer, file-based storage |
| PostgreSQL | Yes | Multiple replicas can connect simultaneously |

### Configuration

For production deployments with PostgreSQL:

```yaml
replicaCount: 2  # or more

storage:
  driver: postgresql
  postgresql:
    host: postgres.example.com
    # ...

podDisruptionBudget:
  enabled: true
  minAvailable: 1

podAntiAffinity:
  enabled: true
  type: soft  # or hard
  topologyKey: kubernetes.io/hostname
```

### Pod Anti-Affinity

Spreads replicas across nodes to prevent single points of failure.

| Type | Behavior |
|------|----------|
| `soft` | Prefers different nodes, allows co-location if necessary |
| `hard` | Requires different nodes, pods won't schedule if unavailable |

### PodDisruptionBudget

Ensures availability during voluntary disruptions (upgrades, node drains):

```yaml
podDisruptionBudget:
  enabled: true
  minAvailable: 1      # At least 1 pod always running
  # maxUnavailable: 1  # Alternative: at most 1 pod down
```
